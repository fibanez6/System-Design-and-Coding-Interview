= Design Patterns
:doctype: article
:toc:
:toclevels: 2

== Patterns of Design

* *Observer Pattern*: The Observer Pattern defines a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.
* *Decorator Pattern*: The Decorator Pattern attaches additional responsibilities to an object dynamically. Decorators provide a flexible alternative to subclassing for extending functionality.
* *Factory Pattern*: The Factory Pattern defines an interface for creating an object, but lets subclasses alter the type of objects that will be created.
* *Singleton Pattern*: The Singleton Pattern ensures a class has only one instance and provides a global point of access to it.
* *Command Pattern*: The Command Pattern encapsulates a request as an object, thereby letting you parameterize clients with different requests, queue or log requests, and support undoable operations.
* *Adapter and Facade Patterns*: The Adapter Pattern allows the interface of an existing class to be used as another interface. The Facade Pattern provides a unified interface to a set of interfaces in a subsystem.
* *Template Method Pattern*: The Template Method Pattern defines the skeleton of an algorithm in a method, deferring some steps to subclasses.
* *Iterator and Composite Pattern*: The Iterator Pattern provides a way to access the elements of an aggregate object sequentially without exposing its underlying representation. The Composite Pattern composes objects into tree structures to represent part-whole hierarchies.
* *State Pattern*: The State Pattern allows an object to alter its behavior when its internal state changes. The object will appear to change its class.
* *Proxy Pattern*: The Proxy Pattern provides a surrogate or placeholder for another object to control access to it.
* *Compound Pattern*: The Compound Pattern combines two or more patterns into a solution that solves a recurring or general problem.

== Creational Patterns
=== Abstract Factory

Provides an interface for creating families of related or dependent objects without specifying their concrete classes.

[source,java]
----
public interface GUIFactory {
    Button createButton();
    Checkbox createCheckbox();
}

public class WinFactory implements GUIFactory {
    public Button createButton() {
        return new WinButton();
    }
    public Checkbox createCheckbox() {
        return new WinCheckbox();
    }
}

public class MacFactory implements GUIFactory {
    public Button createButton() {
        return new MacButton();
    }
    public Checkbox createCheckbox() {
        return new MacCheckbox();
    }
}
----

=== Builder

Separates the construction of a complex object from its representation so that the same construction process can create different representations.

[source,java]
----
public class Director {
    public void construct(Builder builder) {
        builder.buildPartA();
        builder.buildPartB();
    }
}

public interface Builder {
    void buildPartA();
    void buildPartB();
}

public class ConcreteBuilder implements Builder {
    public void buildPartA() {
        // build part A
    }
    public void buildPartB() {
        // build part B
    }
}
----

=== Prototype

Creates new objects by copying an existing object, known as the prototype.

[source,java]
----
public abstract class Prototype implements Cloneable {
    public Prototype clone() throws CloneNotSupportedException {
        return (Prototype) super.clone();
    }
}

public class ConcretePrototype extends Prototype {
    private int field;
    public ConcretePrototype(int field) {
        this.field = field;
    }
}
----
=== Decorator

Allows behavior to be added to individual objects, dynamically, without affecting the behavior of other objects from the same class.

[source,java]
----
public interface Component {
    void operation();
}

public class ConcreteComponent implements Component {
    public void operation() {
        System.out.println("ConcreteComponent operation");
    }
}

public abstract class Decorator implements Component {
    protected Component component;

    public Decorator(Component component) {
        this.component = component;
    }

    public void operation() {
        component.operation();
    }
}

public class ConcreteDecorator extends Decorator {
    public ConcreteDecorator(Component component) {
        super(component);
    }

    public void operation() {
        super.operation();
        System.out.println("ConcreteDecorator additional operation");
    }
}
----

Creational patterns deal with object creation mechanisms, trying to create objects in a manner suitable to the situation.

=== Singleton

Ensures a class has only one instance and provides a global point of access to it.

[source,java]
----
public class Singleton {
    private static Singleton instance;

    private Singleton() {}

    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
----

=== Factory Method

Defines an interface for creating an object, but lets subclasses alter the type of objects that will be created.

[source,java]
----
public abstract class ProductFactory {
    public abstract Product createProduct();
}

public class ConcreteProductFactory extends ProductFactory {
    public Product createProduct() {
        return new ConcreteProduct();
    }
}
----

== Structural Patterns

Structural patterns ease the design by identifying a simple way to realize relationships between entities.
=== Facade

Provides a unified interface to a set of interfaces in a subsystem.

[source,java]
----
public class SubsystemA {
    public void operationA() {
        System.out.println("SubsystemA operation");
    }
}

public class SubsystemB {
    public void operationB() {
        System.out.println("SubsystemB operation");
    }
}

public class Facade {
    private SubsystemA subsystemA = new SubsystemA();
    private SubsystemB subsystemB = new SubsystemB();

    public void operation() {
        subsystemA.operationA();
        subsystemB.operationB();
    }
}
----

=== Proxy

Provides a surrogate or placeholder for another object to control access to it.

[source,java]
----
public interface Subject {
    void request();
}

public class RealSubject implements Subject {
    public void request() {
        System.out.println("RealSubject request");
    }
}

public class Proxy implements Subject {
    private RealSubject realSubject;

    public void request() {
        if (realSubject == null) {
            realSubject = new RealSubject();
        }
        realSubject.request();
    }
}
----

=== Composite

Composes objects into tree structures to represent part-whole hierarchies.

[source,java]
----
import java.util.ArrayList;
import java.util.List;

public interface Component {
    void operation();
}

public class Leaf implements Component {
    public void operation() {
        System.out.println("Leaf operation");
    }
}

public class Composite implements Component {
    private List<Component> children = new ArrayList<>();

    public void add(Component component) {
        children.add(component);
    }

    public void operation() {
        for (Component child : children) {
            child.operation();
        }
    }
}
----

=== Bridge

Decouples an abstraction from its implementation so that the two can vary independently.

[source,java]
----
public interface Implementor {
    void operationImpl();
}

public class ConcreteImplementorA implements Implementor {
    public void operationImpl() {
        System.out.println("ConcreteImplementorA operation");
    }
}

public abstract class Abstraction {
    protected Implementor implementor;

    public Abstraction(Implementor implementor) {
        this.implementor = implementor;
    }

    public abstract void operation();
}

public class RefinedAbstraction extends Abstraction {
    public RefinedAbstraction(Implementor implementor) {
        super(implementor);
    }

    public void operation() {
        implementor.operationImpl();
    }
}
----
=== Adapter

Allows the interface of an existing class to be used as another interface.

[source,java]
----
public interface Target {
    void request();
}

public class Adaptee {
    public void specificRequest() {}
}

public class Adapter implements Target {
    private Adaptee adaptee;

    public Adapter(Adaptee adaptee) {
        this.adaptee = adaptee;
    }

    public void request() {
        adaptee.specificRequest();
    }
}
----

== Behavioral Patterns

Behavioral patterns are concerned with algorithms and the assignment of responsibilities between objects.
=== Strategy

Defines a family of algorithms, encapsulates each one, and makes them interchangeable.

[source,java]
----
public interface Strategy {
    int execute(int a, int b);
}

public class AddStrategy implements Strategy {
    public int execute(int a, int b) {
        return a + b;
    }
}

public class SubtractStrategy implements Strategy {
    public int execute(int a, int b) {
        return a - b;
    }
}

public class Context {
    private Strategy strategy;

    public Context(Strategy strategy) {
        this.strategy = strategy;
    }

    public int executeStrategy(int a, int b) {
        return strategy.execute(a, b);
    }
}
----

=== Command

Encapsulates a request as an object, thereby letting you parameterize clients with different requests.

[source,java]
----
public interface Command {
    void execute();
}

public class LightOnCommand implements Command {
    private Light light;

    public LightOnCommand(Light light) {
        this.light = light;
    }

    public void execute() {
        light.on();
    }
}

public class Light {
    public void on() {
        System.out.println("Light is on");
    }
}

public class RemoteControl {
    private Command command;

    public void setCommand(Command command) {
        this.command = command;
    }

    public void pressButton() {
        command.execute();
    }
}
----

=== State

Allows an object to alter its behavior when its internal state changes.

[source,java]
----
public interface State {
    void handle();
}

public class ConcreteStateA implements State {
    public void handle() {
        System.out.println("State A handling request");
    }
}

public class ConcreteStateB implements State {
    public void handle() {
        System.out.println("State B handling request");
    }
}

public class Context {
    private State state;

    public void setState(State state) {
        this.state = state;
    }

    public void request() {
        state.handle();
    }
}
----

=== Template Method

Defines the skeleton of an algorithm, deferring some steps to subclasses.

[source,java]
----
public abstract class AbstractClass {
    public void templateMethod() {
        primitiveOperation1();
        primitiveOperation2();
    }

    protected abstract void primitiveOperation1();
    protected abstract void primitiveOperation2();
}

public class ConcreteClass extends AbstractClass {
    protected void primitiveOperation1() {
        System.out.println("Operation 1");
    }
    protected void primitiveOperation2() {
        System.out.println("Operation 2");
    }
}
----

=== Observer

Defines a one-to-many dependency between objects so that when one object changes state, all its dependents are notified.

[source,java]
----
public interface Observer {
    void update();
}

public class ConcreteObserver implements Observer {
    public void update() {
        // handle update
    }
}

public class Subject {
    private List<Observer> observers = new ArrayList<>();

    public void addObserver(Observer observer) {
        observers.add(observer);
    }

    public void notifyObservers() {
        for (Observer observer : observers) {
            observer.update();
        }
    }
}
----